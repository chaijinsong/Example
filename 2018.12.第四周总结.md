## 问题

1. 单测中怎样主动出发zactivated的钩子函数

2. 前端怎样实现下载任何形式的文件，而不是跳转新页面
3. var a = 123;
   `a.__proto__`有值，但是`123.__proto__`却没值还报错，为什么？

## 学习

1. defineProperty

   * Vue中很多地方使用 `defineProperty` 而不直接使用 `obj.key` 来设置属性，是因为 `defineProperty` 定义的属性是不可枚举的，但是也可以配置成可枚举。
   * 可以使用 `Object.getOwnPropertyDescriptor(obj, '属性')` 来获取到对应属性的属性描述
   * 注意：`defineProperty` 不能重复定义一个对象的同一属性，否则会报错`Cannot redefine property: 属性名`  

   ```javascript
   let xiaomin = {};
   xiaomin.name = '小明';
   Object.defineProperty(xiaomin, 'age', {
     value: 12
   });
   for(let key in xiaomin){
     console.log(key);
   };
   // name
   Object.defineProperty(xiaomin, 'age2', {
     value: 12,
     enumerable: true // 设置可枚举
   });
   for(let key in xiaomin){
     console.log(key);
   };
   // name, age2
   let describe = Object.getOwnPropertyDescriptor(xiaomin, 'age2');
   /*
   {
     configurable: false
     enumerable: true
     value: 12
     writable: false
   }
   */
   
   ```

2. 三种判断数据类型的方式

   * `Object.prototype.toString.call(val) ` 是比较准确的能够确认数据类型的方式
   * `tpeof xx` 一般用来判断一个操作数的类型，可以得到如下返回值：`undefined object boolean number string symbol function object ` 
   * `object instanceof constructor` 用于测试`constrctor.prototype`属性是否出现在`object`原型链中的任何位置

   ```javascript
   var a = {};
   Object.prototype.toString.call(a); // "[object Object]"
   var b = function () {};
   Object.prototype.toString.call(b); // "[object Function]"
   var c= 1234;
   Object.prototype.toString.call(c); // "[object Number]"
   var d= 'xxxx';
   Object.prototype.toString.call(d); // "[object String]"
   var e = true;
   Object.prototype.toString.call(e); // "[object Boolean]"
   var f = undefined;
   Object.prototype.toString.call(f); // "[object Undefined]"
   var g = null
   Object.prototype.toString.call(g); // "[object Null]"
   var h = [];
   Object.prototype.toString.call(h); // "[object Array]"
   var i = Symbol();
   Object.prototype.toString.call(i); // "[object Symbol]"
   ```

3. 三种设置对象不可拓展的方式

   * `Object.preventExtensions(obj)` : 让`obj` 变的不可拓展，永远不能添加新的属性，但是他仅仅是不能给自己新增属性，原型上还是可以新增的。并且属性可以被 `delete` 删除。可以用 `Object.isExtensible(obj)` 来判断对象是否可拓展
   * `Object.freeze(obj)` : 冻结`obj` ,冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。但是依然可以对原型进行修改
   * `Object.seal(obj)` : 密封`obj` , 阻止添加新属性并将所有现有属性标记为不可配置。和 `freeze` 的区别就是可以修改属性值，而`freeze` 是属性值都不能被修改`obj.a = 123` 在`freeze` 中重新赋值是不行的，在`seal` 中可以

4. git相关内容

   * `git pull === git fetch + git merge` 多了一个merge操作
   * `git commit --amend` : 修改最近一次的commit，可以追加内容，也可以修改message
   * `git rebase -i HEAD~num` : 将前num次的commit进行一个修改，可以合并commit，可以编辑commit
   * `git add -p` : 在一个文件中只想提交该文件中的某一部分，会提示要提交该文件中的某几块，会让我们选择提交哪几部分。或者还可以选择进一步的拆分

5. `setTimeout` 返回值是一个正整数，通过这个编号 `clearTimeout` 才能清除对应的定时器，`setInterval` 和 `setTimeout` 共用一个编号池

6. 防抖和节流

   * 防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行

     * 应用：
       输入框中需要发起请求时，适合使用防抖

     * 原理：
       用一个变量保存 setTimeout 的编号值，每当触发该函数时，将之前的编号`clearTimeout` 掉，然后创建一个新的 setTimeout , 这样能保证在时间间隔内，如果再次触发该函数，就会clear掉上一个，不会执行上一个函数，只有超过时间间隔，才会存在一个 timer 没有被清空，会执行其中的内容

       ```javascript
       // 每次input输入，就调用 debounce，返回一个函数，会执行函数内的内容，函数会先把定时器清除掉。然后重新给timer赋值，等待interval时间过后就发起请求，在这个过程中，如果又触发了debounce，那么就把上次的timer清除掉，这样的话上次执行的定时器就不会执行了，现在重新赋值了。继续等待interval时间，这次在等待时间没触发debounce，就不会清除上次的timer，就会执行具体的内容了。
       function debounce (fn, interval = 300) {
         let timer = null;
         return function () {
           clearTimeout(timer);
           timer = setTimeout(() => {
             fn.apply(this, arguments);
           }, interval);
         }
       }
       ```

   * 节流：指定时间间隔内只会执行一次任务

     * 应用：
       监听 `scroll` 事件时，对应的处理逻辑计算是否到了顶部或底部，可以使用防抖，即超过一定时间间隔才去计算是否到了顶部或底部。

     * 原理：
       定义一个标志位，用来判断是否需要执行对应的逻辑，如果该标志位为真，则执行对应的逻辑，对应的逻辑放在一个定时器里面，定时器代码外把标志位设置为false，这样下次进入该回调时直接return，然后定时器内的内容最后会将标志位设置为true，这样下次进入回调时，就可以执行具体逻辑代码。

       ```javascript
       function throttle (fn, interval=300) {
         let canRun = true; // 标志位true
         return function () {
           if (!canRun) {return}
           canRun = false; // 执行具体代码前，判断标志位，如果为真则设置为false，这样下次进来就会return
           setTimeout(() => {
             fn.apply(this, arguments);
             canRun = true; // 执行完毕具体逻辑代码后，将标志位设置为真，就可以继续下一轮了
           }, interval);
         }
       } 
       ```

   * 节流防抖的区别和适用场景

     * 区别：
       1. 节流是使用的标志位，无论如何到了指定的时间就会执行一次。
       2. 防抖是适用的timer，只有在timer在指定时间内没被清空时会执行，可能会一直不执行。一直触发的话就一直不执行内容。只有停止触发了才会执行。
     * 适用场景：
       1. 节流：频繁触发，但是需要在频繁触发过程中，能在指定的时间间隔执行函数内容。等价于用户一直操作，函数依然需要执行，只不过执行的次数变少。
       2. 防抖：频繁触发，但是只有在指定时间下没有二次触发的时候，才会执行函数内容。可以等价于只有用户停止操作超过一段时间后才会执行。

7. Vue中怎样实现对数组的依赖收集？

   * 数组的下标并不是属性，所以没法用收集对象的依赖一样使用 set 来收集，于是数组依赖收集使用拦截数组的变异方法来实现，即定义同名方法，在方法里调用真正的数组方法，并且做依赖收集

     ```javascript
     // 要拦截的数组变异方法
     const mutationMethods = [
       'push',
       'pop',
       'shift',
       'unshift',
       'splice',
       'sort',
       'reverse'
     ]
     // Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__
     const arrayMethods = Object.create(Array.prototype) // 实现 arrayMethods.__proto__ === Array.prototype
     const arrayProto = Array.prototype  // 缓存 Array.prototype
     
     mutationMethods.forEach(method => {
       arrayMethods[method] = function (...args) {
         const result = arrayProto[method].apply(this, args)
         console.log(`执行了代理原型的 ${method} 函数`)
         return result
       }
     })
     ```

8. OpenAuthoration（第三方平台登陆的技术）

   1. 请求特定OAuth平台的url，带上申请的appid，key等参数
   2. OAuth平台返回一个生命周期很短的code，拼接code到指定的url中再次请求
   3. OAuth平台返回一个access token和refresh token，可以通过access token请求平台相关的数据了，如果access token过期了可以带上refresh token进行重新获取access token

9. 原型链

   ![](/Users/chaijinsong/Documents/每周计划/markdown引用的图片/e83bca5f1d1e6bf359d1f75727968c11_hd.jpg)

   * 每一个对象都有`__proto__` 属性，指向这个对象的构造函数的原型
   * 每一个函数对象都有一个 `prototype` 属性指向该函数对象(函数也是对象)的原型
   * 每一个函数对象的`prototype.constructor` 指向该函数对象本身
   * 所有函数对象的 `__proto__` 指向的都是 `Function.prototype` 

   ```javascript
   var obj = {};
   obj.__proto__ === Object.prototype; // 对象的 __proto__ 指向这个对象构造函数的原型
   var obj2 = 123;
   obj2.__proto__ === Number.prototype; // true
   var obj3 = 'xxx';
   obj3.__proto__ === String.prototype; // true
   var obj4 = function () {};
   obj4.__proto__ === Function.prototype; // 函数都是通过Function构造函数创建的
   var obj5 = null; 
   obj5.__proto__ === Object.prototype; // null是没有__proto__的，会报错
   var obj6 = NaN;
   obj6.__proto__ === Number.prototype; // NaN也是通过Number造的
   
   var obj7 = function(){};
   obj7.prototype.constructor === obj7; // 函数对象的原型的constructor指向该函数对象自己
   
   Object.prototype.__proto__ === null; // true
   
   Function.prototype.__proto__ === Object.prototype; // Function.prototype也是一个对象，所以他的__proto__ 指向的是该对象的构造函数的原型，即Object.prototype
   ```

10. 三种实现封装内部数据的方式（类似于java的私有属性）

    * es6的`Proxy` (对象代理) : 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等） 

      ```javascript
      var Person = {
        name: 'es3',
        sex: 'female',
        age: 12
      };
      let person = new Proxy(Person, {
        get(target, key) {
          // target就是 Person, key就是属性
          return target[key];
        },
        set(target, key, value) {
          // 可以在这里进行各种规则设置
          if (key !== 'sex') {
      	  target[key] = value;
          }
        }
      });
      person.sex = 'male'; // 不起作用
      ```

    * es5

      ```javascript
      // 不能设置规则，哪种情况哪些属性可以读写，使用defineProperty就搞不定
      var Person = {
        name: 'es3',
        sex: 'female',
        age: 12
      };
      Object.defineProperty(Person, 'sex', {
        writable: false,
        value: 'female'
      });
      Person.sex = 'male'; // Person.sex === female; 会失败,严格模式会报错。
      ```

    * es3

      ```javascript
      function Person = {
        var data = {
          name: 'es3',
          sex: 'female',
          age: 12
        };
        this.get = function (key) {
          return data[key];
        }
        this.set = function (key, value) {
          if (key !== 'sex') {
            data[key] = value;
          }
        }
      };
      var person = new Person();
      console.table({
        name: person.get('name'),
        sex: person.get('sex'),
        age: person.get('age')
      });// name: 'es3', sex: 'female', age: 12
      person.set('sex', 'male'); // person.get('sex') === 'female' 对set做了判断，所以设置没用，这样就通过定义实例的 set和get方式来保护 内部的data变量
      ```

## 反思

1. 向电脑一样决策思考，例如丢弃衣柜中的衣服，可以使用计算机调度任务的几种策略，其中最近不常用策略能够让我们以后找衣服效率更高，因为衣柜中都是存放的自己穿的较多的衣服
2. 37% 最优停止理论，最终获取xx的机会会超过1/3，这不是很大的可能性，但是这个比例是通过计算得到的可以期待的最好策略。打个比方，比如你游完一个景点，想买一点旅游纪念品，抬头一看一条街上有10家旅游纪念品商铺，如何买到质量最好价格最优的呢？也是37%法则，前4家只看不买，后面碰到比前4家更好的就下手。